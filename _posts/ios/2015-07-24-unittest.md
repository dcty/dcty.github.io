---
layout: post
title: 单元测试
category: ios
keywords: 单元测试
---


接着五娃的[文章](http://meiyou.im/23)，我讲一下XCTest  
单元测试的开源库还有不少大家可以自己去[看看](http://nshipster.com/unit-testing/#open-source-libraries)  
因为我们现在开发的APP，绝大部分都需需要网络交互的  
早期的XCTest并不支持异步测试，所以导致很多人都不喜欢写单元测试  
[而现在已经支持了](http://nshipster.com/xctestcase/)  
```objective-c
- (void)testAsynchronousURLConnection {
NSURL *URL = [NSURL URLWithString:@"http://nshipster.com/"];
NSString *description = [NSString stringWithFormat:@"GET %@", URL];
XCTestExpectation *expectation = [self expectationWithDescription:description];
NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionDataTask *task = [session dataTaskWithURL:URL
completionHandler:^(NSData *data, NSURLResponse *response, NSError *error)
{
XCTAssertNotNil(data, "data should not be nil");
XCTAssertNil(error, "error should be nil");

if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
XCTAssertEqual(httpResponse.statusCode, 200, @"HTTP response status code should be 200");
XCTAssertEqualObjects(httpResponse.URL.absoluteString, URL.absoluteString, @"HTTP response URL should be equal to original URL");
XCTAssertEqualObjects(httpResponse.MIMEType, @"text/html", @"HTTP response content type should be text/html");
} else {
XCTFail(@"Response was not NSHTTPURLResponse");
}

[expectation fulfill];
}];

[task resume];

[self waitForExpectationsWithTimeout:task.originalRequest.timeoutInterval handler:^(NSError *error) {
if (error != nil) {
NSLog(@"Error: %@", error.localizedDescription);    
}
[task cancel];
}];
}
```

如果需要对某个方法进行性能测试的话，可以用`measureBlock`这东西  
原先我们对一个方法进行性能测试的话，无非就是连续跑几次，然后取平均值，而现在`measureBlock `就是干这活的  
```objective-c
- (void)testDateFormatterPerformance {
NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
dateFormatter.dateStyle = NSDateFormatterLongStyle;
dateFormatter.timeStyle = NSDateFormatterShortStyle;

NSDate *date = [NSDate date];

[self measureBlock:^{
NSString *string = [dateFormatter stringFromDate:date];
}];
}
```

好的，上面的东西，都是网络上能找到的，下面讲讲我们用RAC如何进行单元测试  
因为我们RAC的库通过pod导入，所以在写单元测试的时候直接导入头文件的话，会报错  
解决方案有[多个](),这里只讲比较简单的

platform :ios,'6.0'
link_with 'UnitTest','UnitTestTests' //顾名思义，link到多个target
pod 'ReactiveCocoa'

现在我们写一个signal，然后跑一下试试看

[[viewModel testSignal].logAll asynchronouslyWaitUntilCompleted:NULL];
好的，一切正常了，那我们再来写一个command试一下

[[viewModel.testCommand execute:nil].logAll asynchronouslyWaitUntilCompleted:NULL];
这时候会发现，逗比了，又报错了！！！  
逗比楼主当时也折腾了很久，后来采用了一招`将ViewModel文件加入到test的target里面就好了`  
先吃口💩冷静一下，不要问我为什么，我已经忘记原因了。
差点忘记说RAC的优势了。
==	 
这货提供了两个方法，都是开发，我就不说了，注释自己看吧。
```objective-c
@interface RACSignal (Testing)

/// Spins the main run loop for a short while, waiting for the receiver to send a `next`.
///
/// **Because this method executes the run loop recursively, it should only be used
/// on the main thread, and only from a unit test.**
///
/// defaultValue - Returned if the receiver completes or errors before sending
///                a `next`, or if the method times out. This argument may be
///                nil.
/// success      - If not NULL, set to whether the receiver completed
///                successfully.
/// error        - If not NULL, set to any error that occurred.
///
/// Returns the first value received, or `defaultValue` if no value is received
/// before the signal finishes or the method times out.
- (id)asynchronousFirstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error;

/// Spins the main run loop for a short while, waiting for the receiver to complete.
///
/// **Because this method executes the run loop recursively, it should only be used
/// on the main thread, and only from a unit test.**
///
/// error - If not NULL, set to any error that occurs.
///
/// Returns whether the signal completed successfully before timing out. If NO,
/// `error` will be set to any error that occurred.
- (BOOL)asynchronouslyWaitUntilCompleted:(NSError **)error;

@end
```


对了，为什么我会想把我们的架构由MVC往MVVM上改  
因为ViewModel是一个可单独测试的东西，iOS的MVC在ViewController里面加了太多的东西会增加单元测试的难度，甚至是不可测试。